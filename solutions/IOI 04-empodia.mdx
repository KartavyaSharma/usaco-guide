---
id: ioi-04-empodia
source: IOI 2004
title: Empodia
author: Benjamin Qi, Andi Qu
---

[Official Editorial](https://ioinformatics.org/page/ioi-2004/30)

**Time Complexity:** $\mathcal O(N)$.

Let $v[0],v[1],\ldots,v[n-1]$ denote the input sequence. An interval $[i\ldots j]$ is framed if all three of the following conditions hold: 

 - $v[i]-i=v[j]-j$
 - $v[i]=\min(v[i\ldots j])$
 - $v[j]=\max(v[i\ldots j])$

Our approach will be to iterate over all $j=[0,n)$ and check whether $j$ contributes a new empodio with right endpoint $j$.

 - Maintain a stack $mn$ consisting of all indices $i$ satisfying the second condition. 
 - When we increment $j$, repeatedly pop the top element $i$ of $mn$ while $v[i]>v[j]$. Then add $j$ to $mn$.
 - To check whether $j$ is part of an empodio, find the maximum $i\in mn$ such that $v[i]-i=v[j]-j$. If $i$ is to the right of the rightmost left endpoint of any empodio found so far and $v[j]=\max(v[i\ldots j])$, then we have found a new empodio.

To check whether $v[j]=\max(v[i\ldots j])$, we can maintain a separate stack $mx$ that stores all indices $i$ such that $v[i]=\max(v[i\ldots j])$.

**Note:** The test data on Yandex has sequences of length greater than $1100000$ $\ldots$

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[2000000], le[2000000], gr[2000000];

int main() {
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	int n;
	map<int, stack<int>> mp;
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> a[i];
		mp[a[i] - i].push(i);
	}
	stack<int> stck;
	for (int i = 0; i < n; i++) {
		while (stck.size() && a[stck.top()] < a[i]) stck.pop();
		if (stck.size())
			gr[i] = stck.top();
		else
			gr[i] = -1;
		stck.push(i);
	}
	while (stck.size()) stck.pop();
	for (int i = n - 1; ~i; i--) {
		while (stck.size() && a[stck.top()] > a[i]) stck.pop();
		if (stck.size())
			le[i] = stck.top();
		else
			le[i] = n;
		stck.push(i);
	}

	vector<pair<int, int>> potential, empodia;
	for (pair<int, stack<int>> i : mp) {
		stack<int> active;
		while (i.second.size()) {
			while (active.size()) {
				if (le[i.second.top()] < active.top()) break;
				if (gr[active.top()] > i.second.top())
					active.pop();
				else {
					potential.push_back({i.second.top(), active.top()});
					break;
				}
			}
			active.push(i.second.top());
			i.second.pop();
		}
	}

	sort(potential.begin(), potential.end(), greater<pair<int, int>>());
	for (pair<int, int> i : potential)
		if (!empodia.size() || empodia.back().second > i.second)
			empodia.push_back(i);

	cout << empodia.size() << '\n';
	while (empodia.size()) {
		cout << empodia.back().first + 1 << ' ' << empodia.back().second + 1 << '\n';
		empodia.pop_back();
	}
	return 0;
}
```

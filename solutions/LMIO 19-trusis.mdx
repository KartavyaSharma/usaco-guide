---
id: lmio-19-trusis
source: LMIO 2019
title: Rabbit Carrot
author: Benjamin Qi, Andi Qu
---

<Spoiler title="Hint">

Instead of minimizing the # of poles whose heights we change, let's maximize the # of poles whose heights we do **not** change. 

</Spoiler>

<Spoiler title="Condition">

Let the heights of the poles be $a_1,\ldots,a_N$. If the heights of poles $i_1<i_2<\cdots<i_k$ do **not** change, then we should have

$$
a_{i_j}\le M\cdot i_j
$$

$$
a_{i_{j+1}}\le a_{i_j}+M\cdot (i_{j+1}-i_j)
$$

for all $1\le j<k$.

</Spoiler>

<Spoiler title="Finishing">

We can rewrite these inequalities above as

$$
0\le M\cdot i_1-a_{i_1}
$$

$$
M\cdot i_j-a_{i_j}\le M\cdot i_{j+1}-a_{i_{j+1}}
$$

Letting $b_i=M\cdot i-a_i$ for each $1\le i\le N$, it follows that

$$
0\le b_{i_1}
$$
$$
b_{i_j}\le b_{i_{j+1}}
$$

so we've reduced the problem to finding the longest non-decreasing subsequence of $b$!

```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;

vector<ll> lis = {0};

int main() {
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		int h;
		cin >> h;
		ll v = -h + m * i;
		if (v < 0) continue;
		int ub = upper_bound(lis.begin(), lis.end(), v) - lis.begin();
		if (ub == lis.size()) lis.push_back(v);
		else lis[ub] = v;
	}
	cout << n - lis.size() + 1;
	return 0;
}
```

</Spoiler>

**Bonus**: Can you solve the case where the rabbit can jump at most $M$ units down and at most $M$ units up?

<Spoiler title="Spoiler">

Let $b_i$ be as defined above, and let $c_i=M\cdot i+a_i$. Then we should have both both


$$
b_{i_j}\le b_{i_{j+1}}
$$

and

$$
c_{i_j}\le c_{i_{j+1}}
$$

Note that it is impossible for both of these conditions to hold if $i_j>i_{j+1}$. To finish, we can just sort the points $(b_i,c_i)$ in lexicographical order for each $1\le i\le N$ and run an LIS algorithm on the $y$-coordinates.

</Spoiler>
